//
//  Token.swift
//  MinCamlSwiftPackageDescription
//
//  Created by 藤井陽介 on 2017/11/07.
//

import Foundation

// MARK: - Token

/// The different kinds a token generated by the lexer can have
/// - integer:
/// - floating number:
/// - boolean:
/// - identifier: An identifier
/// - `operator`: A operator
/// - leftParen: '('
/// - rightParen: ')'
/// - semiColon
/// - endOfFile: Artificial token to represent the end of a file
public enum TokenKind: CustomStringConvertible {
    
    // MARK: Keyword
    /// The 'if' keyword
    case `if`
    /// The 'then' keyword
    case then
    /// The 'else' keyword
    case `else`
    /// The 'let' keyword
    case `let`
    /// The 'in' keyword
    case `in`
    /// The 'rec' keyword
    case rec
    /// The 'fun' keyword
    case fun
    /// The 'create_array' keyword
    /// Maybe it can be "Array.create" or "Array.make"
    case createArray
    /// The 'input' keyword
    case input
    /// The 'output' keyword
    case output
    
    // MARK: Operator
    /// The 'not' keyword
    case not
    
    // MARK: Literal
    /// An integer literal
    case integer(value: Int)
    /// A floating number literal
    case float(value: Double)
    /// A boolean literal
    case boolean(value: Bool)
    /// An identifier
    case identifier(name: String)
    /// An operator
    case `operator`(name: String)
    /// A comment
    case comment
    
    // MARK: Symbol
    /// `(`
    case leftParen
    /// `)`
    case rightParen
    /// ','
    case comma
    /// '_'
    case underscore
    /// '.'
    case dot
    /// '<-'
    case lessMinus
    /// '->'
    case minusGreater
    /// ';'
    case semicolon
    
    case endOfFile
    
    public var description: String {
        
        switch self {
        case .if:
            return "Keyword if"
        case .then:
            return "Keyword then"
        case .else:
            return "Keyword else"
        case .let:
            return "Keyword let"
        case .in:
            return "Keyword in"
        case .rec:
            return "Keyword rec"
        case .fun:
            return "Keyword fun"
        case .createArray:
            return "Create Array"
        case .input:
            return "Keyword input"
        case .output:
            return "Keyword output"
        case .not:
            return "Keyword not"
        case .integer(let value):
            return "Integer \(value)"
        case .float(let value):
            return "Floating Point Number \(value)"
        case .boolean(let value):
            return "Boolean \(value)"
        case .identifier(let name):
            return "Identifier \(name)"
        case .operator(let name):
            return "Operator \(name)"
        case .comment:
            return "Comment"
        case .leftParen:
            return "Left paranthesis '('"
        case .rightParen:
            return "Right parenthesis ')'"
        case .comma:
            return "Comma ','"
        case .underscore:
            return "Underscore '_'"
        case .dot:
            return "Dot '.'"
        case .lessMinus:
            return "Less Minus '<-'"
        case .minusGreater:
            return "Minus Greater '->'"
        case .semicolon:
            return "Semicolon ';'"
        case .endOfFile:
            return "End of file"
        }
    }
    
    public var sourceCodeRepresentation: String {
        
        switch self {
        case .if:
            return "if"
        case .then:
            return "then"
        case .else:
            return "else"
        case .let:
            return "let"
        case .in:
            return "in"
        case .rec:
            return "rec"
        case .fun:
            return "fun"
        case .createArray:
            return "create_array"
        case .input:
            return "input"
        case .output:
            return "output"
        case .not:
            return "not"
        case .integer(let value):
            return "\(value)"
        case .float(let value):
            return "\(value)"
        case .boolean(let value):
            return "\(value)"
        case .identifier(let name):
            return "\(name)"
        case .operator(let name):
            return "\(name)"
        case .comment:
            return "(* comment *)"
        case .leftParen:
            return "("
        case .rightParen:
            return ")"
        case .comma:
            return ","
        case .underscore:
            return "_"
        case .dot:
            return "."
        case .lessMinus:
            return "<-"
        case .minusGreater:
            return "->"
        case .semicolon:
            return ";"
        case .endOfFile:
            return "eof"
        }
    }
}

extension TokenKind: Equatable {
    
    public static func ==(lhs: TokenKind, rhs: TokenKind) -> Bool {
        
        switch (lhs, rhs) {
        case (.if, .if):
            return true
        case (.then, .then):
            return true
        case (.else, .else):
            return true
        case (.let, .let):
            return true
        case (.in, .in):
            return true
        case (.rec, .rec):
            return true
        case (.fun, .fun):
            return true
        case (.createArray, .createArray):
            return true
        case (.input, .input):
            return true
        case (.output, .output):
            return true
        case (.not, .not):
            return "true
        case (.integer(let lhsValue), .integer(let rhsValue)) where lhsValue == rhsValue:
            return true
        case (.float(let lhsValue), .float(let rhsValue)) where lhsValue == rhsValue:
            return true
        case (.boolean(let lhsValue), .boolean(let rhsValue)) where lhsValue == rhsValue:
            return true
        case (.identifier(let lhsName), .identifier(let rhsName)) where lhsName == rhsName:
            return true
        case (.operator(let lhsName), .operator(let rhsName)) where lhsName == rhsName:
            return true
        case (.comment, .comment):
            return true
        case (.leftParen, .leftParen):
            return true
        case (.rightParen, .rightParen):
            return true
        case (.comma, .comma):
            return true
        case (.underscore, .underscore):
            return true
        case (.dot, .dot):
            return true
        case (.lessMinus, .lessMinus):
            return true
        case (.minusGreater, .minusGreater):
            return true
        case (.semicolon, .semicolon):
            return true
        case (.endOfFile, .endOfFile):
            return true
        default:
            return false
        }
    }
}

public func ==(token: Token, tokenKind: TokenKind) -> Bool {
    
    return token.payload == tokenKind
}

public func !=(token: Token, tokenKind: TokenKind) -> Bool {
    
    return !(token == tokenKind)
}

/// A token generated by the lexer
public struct Token {
    
    /// The actual payload of the token
    public let payload: TokenKind
    
    /// The source range where this token appeared
    public let sourceRange: SourceRange
    
    init(_ payload: TokenKind, sourceRange: SourceRange) {
        
        self.payload = payload
        self.sourceRange = sourceRange
    }
}
